{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Memorização de algoritmos","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"memorização-de-algoritmos\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Memoriza\\xE7\\xE3o de algoritmos\"), mdx(\"p\", null, \"Acredito que talvez a melhor forma de memorizar sequ\\xEAncias de algoritmos \\xE9 usando \", \"[chunking]\", \", agrupando sequ\\xEAncias de movimentos de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Notacao-do-Cubo-Magico\",\n    \"title\": \"Notação do Cubo Mágico\"\n  }), \"[[Nota\\xE7\\xE3o do Cubo M\\xE1gico]]\"), \" em peda\\xE7os conhecidos como \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Triggers-de-algoritmos\",\n    \"title\": \"Triggers de algoritmos\"\n  }), \"[[Triggers de algoritmos]]\"), \"\"), mdx(\"p\", null, \"Existe uma \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Notacao-do-Cubo-Magico\",\n    \"title\": \"Notação do Cubo Mágico\"\n  }), \"[[Nota\\xE7\\xE3o do Cubo M\\xE1gico]]\"), \" chamada de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Notacao-de-Wolstenholme\",\n    \"title\": \"Notação de Wolstenholme\"\n  }), \"[[Nota\\xE7\\xE3o de Wolstenholme]]\"), \" que transforma sequ\\xEAncias de algoritmos em s\\xEDlabas que s\\xE3o mais facilmente memorizadas\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"notação-do-cubo-mágico\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Nota\\xE7\\xE3o do Cubo M\\xE1gico\"), mdx(\"p\", null, \"A nota\\xE7\\xE3o de cubo m\\xE1gico  \\xE9 chamada de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Rubik%27s_Cube#Move_notation\"\n  }), \"Singmaster\"), \" e \\xE9 expressa em ingl\\xEAs.\"), mdx(\"p\", null, \"Quando houver o s\\xEDmbolo \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"plica\"), \" (') depois da letra, significa um giro anti-hor\\xE1rio da face, enquanto a letra sem (') denota um giro hor\\xE1rio.\"), mdx(\"p\", null, \"Uma letra seguida pelo 2 ou \\xB2 denota dois giros, ou um giro de 180\\xB0.\"), mdx(\"p\", null, \"As letras x, y e z s\\xE3o usadas para indicar que o cubo inteiro deve ser girado em torno de um de seus eixos e a mesma nota\\xE7\\xE3o anterior se aplica.\"), mdx(\"p\", null, \"O desvio mais comum da nota\\xE7\\xE3o Singmaster \\xE9 usar \\\"w\\\", quando se referir \\xE0 duas camadas que devem ser giradas, por exemplo, em vez de r, usa-se Rw. Sendo este o padr\\xE3o oficial de nota\\xE7\\xE3o da WCA.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"F\"), \" (Front): o lado voltado para quem esta resolvendo\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"B\"), \" (Back): o lado oposto da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"U\"), \" (Up): o lado acima ou em cima do lado da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"D\"), \" (Down): o lado oposto ao topo, ou a parte de baixo do cubo\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"L\"), \" (Left): o lado diretamente \\xE0 esqueda da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"R\"), \" (Right): o lado diretamente \\xE0 direita da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"\\u0192\"), \" (Front two layers): o lado de frente para quem est\\xE1 resolvendo e a camada do meio coerrespondente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"b\"), \" (Back two layers): a camada oposta \\xE0 frente e sua camada do meio correspondente \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"u\"), \" (Up two layers): a camada de cima de cima e sua camada do meio correspondente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"d\"), \" (Down two layers): a camada de baixo e  sua camada do meio correspondente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"l\"), \" (Left two layers): a camada \\xE0 esquerda do lado da frente e sua camada do meio correspondente \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"r\"), \" (Right two layers): a camada \\xE0 direita do lado da frente e sua camada do meio correspondente \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"x\"), \" (rotate): rotar o cubo inteiro em R\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"y\"), \" (rotate): rotar o cubo inteiro em U\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"z\"), \" (rotate): rotar o cubo inteiro em F \")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://assets1.ello.co/uploads/asset/attachment/4123434/ello-optimized-81fbd399.gif\"\n  }), mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"src\": \"https://assets1.ello.co/uploads/asset/attachment/4123434/ello-optimized-81fbd399.gif\",\n    \"alt\": \"Notação do Cubo mágico\"\n  })))), mdx(\"p\", null, \"Para m\\xE9todos que utilizam giros da camada do meio, existe uma extens\\xE3o \\\"MES\\\", onde as letras M,E e S denotam giros do meio.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"M\"), \" (Middle):  a camada entre L e R, girada na mesma dire\\xE7\\xE3o que L (cima-baixo)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"E\"), \" (Equator): a camada entre U e D, girada na mesma dire\\xE7\\xE3o que D (esquerda-direita)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"S\"), \" (Standing): a camda entre F e B, girada na mesma dire\\xE7\\xE3o que F\")), mdx(\"p\", null, \"Ainda existe uma nota\\xE7\\xE3o alternativa, chamada de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Notacao-de-Wolstenholme\",\n    \"title\": \"Notação de Wolstenholme\"\n  }), \"[[Nota\\xE7\\xE3o de Wolstenholme]]\"), \", que foi feita para tornar a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Memorizacao-de-algoritmos\",\n    \"title\": \"Memorização de algoritmos\"\n  }), \"[[Memoriza\\xE7\\xE3o de algoritmos]]\"), \" mais f\\xE1cil para quem est\\xE1 come\\xE7ando.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"aa0f982d-765b-577d-9bdc-f5a866f664ee","fields":{"slug":"/Notação do Cubo Mágico","title":"Notação do Cubo Mágico"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"triggers-de-algoritmos\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Triggers de algoritmos\"), mdx(\"p\", null, \"Al\\xE9m de auxiliarem na memoriza\\xE7\\xE3o de algoritmos, acredito que estes algoritmos possam ser usados para o treinamento de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Fingertricks\",\n    \"title\": \"Fingertricks\"\n  }), \"[[Fingertricks]]\"), \"\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sexy move -( RUR\\u2019U\\u2019 )\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Anti sexy - ( URU\\u2019R\\u2019 )\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sledgehammer - (R\\u2019FRF\\u2019)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Hedge - (FR\\u2019F\\u2019R)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Rocket -( RU2R\\u2019)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pulley - (RUR2\\u2019)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Jackhammer -( R2FRF\\u2019 )\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Hackjammer - (FR\\u2019F\\u2019R2)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Big Sexy - (RU2R\\u2019U2\\u2019)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Snap - (RU\\u2019R2)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Start -( RUR\\u2019)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Stop - (R\\u2019U\\u2019R)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Putty -( RU2R\\u2019)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Super - (R\\u2019U2R)\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a76b689b-3963-5e41-8702-26ce32d7574a","fields":{"slug":"/Triggers de algoritmos","title":"Triggers de algoritmos"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"notação-de-wolstenholme\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Nota\\xE7\\xE3o de Wolstenholme\"), mdx(\"p\", null, \"As letras s\\xE3o as mesmas, apenas trocando U por T(top), assim todas as letras s\\xE3o consoantes. A diferen\\xE7a principal est\\xE1 no uso das vogais O, A e I para hor\\xE1rio, antihor\\xE1rio e giros duplos (180\\xB0) resultando em sequ\\xEAncias do tipo LOTA RATO LATA ROTI (LU\\u2032R\\u2032UL\\u2032U\\u2032RU2 em Singmaster).  C significa rota\\xE7\\xE3o de todo o cubo, ent\\xE3o ROC, seria uma rota\\xE7\\xE3o hor\\xE1ria do cubo em torno da sua face direita. Camadas do meio s\\xE3o denotadas com um M adicionada ao moviemnto da face correspondente, ent\\xE3o RIM significa um giro de 180\\xB0 da camada do meio adjacente \\xE0 face R.\"), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"referências\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Refer\\xEAncias\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://www.topaccolades.com/notation/rubikscube.htm\"\n  }), \"http://www.topaccolades.com/notation/rubikscube.htm\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"e729a5c3-0cea-5cc0-825f-2f578a330c63","fields":{"slug":"/Notação de Wolstenholme","title":"Notação de Wolstenholme"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"notação-do-cubo-mágico\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Nota\\xE7\\xE3o do Cubo M\\xE1gico\"), mdx(\"p\", null, \"A nota\\xE7\\xE3o de cubo m\\xE1gico  \\xE9 chamada de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Rubik%27s_Cube#Move_notation\"\n  }), \"Singmaster\"), \" e \\xE9 expressa em ingl\\xEAs.\"), mdx(\"p\", null, \"Quando houver o s\\xEDmbolo \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"plica\"), \" (') depois da letra, significa um giro anti-hor\\xE1rio da face, enquanto a letra sem (') denota um giro hor\\xE1rio.\"), mdx(\"p\", null, \"Uma letra seguida pelo 2 ou \\xB2 denota dois giros, ou um giro de 180\\xB0.\"), mdx(\"p\", null, \"As letras x, y e z s\\xE3o usadas para indicar que o cubo inteiro deve ser girado em torno de um de seus eixos e a mesma nota\\xE7\\xE3o anterior se aplica.\"), mdx(\"p\", null, \"O desvio mais comum da nota\\xE7\\xE3o Singmaster \\xE9 usar \\\"w\\\", quando se referir \\xE0 duas camadas que devem ser giradas, por exemplo, em vez de r, usa-se Rw. Sendo este o padr\\xE3o oficial de nota\\xE7\\xE3o da WCA.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"F\"), \" (Front): o lado voltado para quem esta resolvendo\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"B\"), \" (Back): o lado oposto da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"U\"), \" (Up): o lado acima ou em cima do lado da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"D\"), \" (Down): o lado oposto ao topo, ou a parte de baixo do cubo\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"L\"), \" (Left): o lado diretamente \\xE0 esqueda da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"R\"), \" (Right): o lado diretamente \\xE0 direita da frente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"\\u0192\"), \" (Front two layers): o lado de frente para quem est\\xE1 resolvendo e a camada do meio coerrespondente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"b\"), \" (Back two layers): a camada oposta \\xE0 frente e sua camada do meio correspondente \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"u\"), \" (Up two layers): a camada de cima de cima e sua camada do meio correspondente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"d\"), \" (Down two layers): a camada de baixo e  sua camada do meio correspondente\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"l\"), \" (Left two layers): a camada \\xE0 esquerda do lado da frente e sua camada do meio correspondente \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"r\"), \" (Right two layers): a camada \\xE0 direita do lado da frente e sua camada do meio correspondente \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"x\"), \" (rotate): rotar o cubo inteiro em R\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"y\"), \" (rotate): rotar o cubo inteiro em U\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"z\"), \" (rotate): rotar o cubo inteiro em F \")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://assets1.ello.co/uploads/asset/attachment/4123434/ello-optimized-81fbd399.gif\"\n  }), mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"src\": \"https://assets1.ello.co/uploads/asset/attachment/4123434/ello-optimized-81fbd399.gif\",\n    \"alt\": \"Notação do Cubo mágico\"\n  })))), mdx(\"p\", null, \"Para m\\xE9todos que utilizam giros da camada do meio, existe uma extens\\xE3o \\\"MES\\\", onde as letras M,E e S denotam giros do meio.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"M\"), \" (Middle):  a camada entre L e R, girada na mesma dire\\xE7\\xE3o que L (cima-baixo)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"E\"), \" (Equator): a camada entre U e D, girada na mesma dire\\xE7\\xE3o que D (esquerda-direita)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"S\"), \" (Standing): a camda entre F e B, girada na mesma dire\\xE7\\xE3o que F\")), mdx(\"p\", null, \"Ainda existe uma nota\\xE7\\xE3o alternativa, chamada de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Notacao-de-Wolstenholme\",\n    \"title\": \"Notação de Wolstenholme\"\n  }), \"[[Nota\\xE7\\xE3o de Wolstenholme]]\"), \", que foi feita para tornar a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Memorizacao-de-algoritmos\",\n    \"title\": \"Memorização de algoritmos\"\n  }), \"[[Memoriza\\xE7\\xE3o de algoritmos]]\"), \" mais f\\xE1cil para quem est\\xE1 come\\xE7ando.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"aa0f982d-765b-577d-9bdc-f5a866f664ee","fields":{"slug":"/Notação do Cubo Mágico","title":"Notação do Cubo Mágico"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"como-resolver-o-cubo-mágico\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Como resolver o cubo m\\xE1gico\"), mdx(\"div\", {\n    \"align\": \"right\"\n  }, \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"div\"\n  }, {\n    \"alt\": \"Cubo mágico\",\n    \"src\": \"https://i.imgur.com/GVOigDD.png\",\n    \"style\": {\n      \"maxHeight\": \"100px\",\n      \"width\": \"80\",\n      \"height\": \"auto\",\n      \"maxWidth\": \"100%\"\n    }\n  }))), mdx(\"p\", null, \"Cubo m\\xE1gico \\xE9 um puzzle inventado em 1974 pelo professor H\\xFAngaro Ern\\u0151 Rubik.\"), mdx(\"p\", null, \"Para resolver o cubo m\\xE1gico \\xE9 antes preciso ter algumas no\\xE7\\xF5es b\\xE1sicas, entender a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Notacao-do-Cubo-Magico\",\n    \"title\": \"Notação do Cubo Mágico\"\n  }), \"[[Nota\\xE7\\xE3o do Cubo M\\xE1gico]]\"), \" para saber ler \", \"[algoritmos para montagem do cubo m\\xE1gico]\", \" e  realizar a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Memorizacao-de-algoritmos\",\n    \"title\": \"Memorização de algoritmos\"\n  }), \"[[Memoriza\\xE7\\xE3o de algoritmos]]\"), \".\"), mdx(\"p\", null, \"Existem diversos m\\xE9todos para resolu\\xE7\\xE3o do cubo m\\xE1gico,\\nSaber resolver o cubo m\\xE1gico \\xE9 algo semelhante a fazer m\\xE1gica, enquanto voc\\xEA n\\xE3o sabe o truque parece algo imposs\\xEDvel, mas uma vez que voc\\xEA aprende se torna algo normal, seria algo trivial se n\\xE3o fosse a possibilidade de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Se-tornar-mais-rapido-no-3X3\",\n    \"title\": \"Se tornar mais rápido no 3X3\"\n  }), \"[[Se tornar mais r\\xE1pido no 3X3]]\"), \".\"), mdx(\"p\", null, \"\\xC9 util ter uma esp\\xE9cie de \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Roadmap-cubo-magico\",\n    \"title\": \"Roadmap cubo mágico\"\n  }), \"[[Roadmap cubo m\\xE1gico]]\"), \", para saber o que aprender e quais milestones perseguir.\"), mdx(\"p\", null, \"Acredito que a melhor alternativa para se tornar melhor seja a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/A-utilizacao-de-Pratica-Deliberada-na-montagem-do-cubo-magico\",\n    \"title\": \"A utilização de Prática Deliberada na montagem do cubo mágico\"\n  }), \"[[A utiliza\\xE7\\xE3o de Pr\\xE1tica Deliberada na montagem do cubo m\\xE1gico]]\"), \" \"), mdx(\"p\", null, \"Acredito que seja poss\\xEDvel usar o \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Anki\",\n    \"title\": \"Anki\"\n  }), \"[[Anki]]\"), \", usando \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Repeticao-Espacada-como-forma-de-aumentar-memoria-de-longo-prazo\",\n    \"title\": \"Repetição Espaçada como forma de aumentar memória de longo prazo\"\n  }), \"[[Repeti\\xE7\\xE3o Espa\\xE7ada como forma de aumentar mem\\xF3ria de longo prazo]]\"), \" dos algoritmos aprendidos.\"), mdx(\"p\", null, \"\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/Resolver-o-cubo-magico-vendado\",\n    \"title\": \"Resolver o cubo mágico vendado\"\n  }), \"[[Resolver o cubo m\\xE1gico vendado]]\"), \"\"), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"referências\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Refer\\xEAncias\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.reddit.com/r/Cubers/wiki/how_to_improve\"\n  }), \"https://www.reddit.com/r/Cubers/wiki/how_to_improve\"))), mdx(\"h2\", {\n    \"id\": \"ferramentas\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Ferramentas\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://christianvaughn.net/C2F2L/\"\n  }), \"https://christianvaughn.net/C2F2L/\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A tool to practice cross and transition to F2L\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://cstimer.net/\"\n  }), \"https://cstimer.net/\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Timer\")))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"79dac59e-614d-5a9c-a8e3-2d0a0944bc69","fields":{"slug":"/Como resolver o cubo mágico","title":"Como resolver o cubo mágico"}}}]},"fields":{"slug":"/Memorização de algoritmos","title":"Memorização de algoritmos"}}},"pageContext":{"id":"78b992b6-f61f-5ddd-b57e-a4beb37b8c42"}},"staticQueryHashes":["2098632890","426988268"]}